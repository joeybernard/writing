Mercurial - Revision Control Approximated

A short while ago, an article appeared in Linux Journal which implied that git was the be-all and end-all of source code revision control systems (Git - Revision control perfected, August 2011). Well, I would like to challenge that assumption and declare to the world that the REAL perfect version control system is here, and its name is mercurial.

In case you didn't notice it, my tongue was firmly in my cheek in the last paragraph. I think version control systems are like editors. They are all different, and fit people and their work habits differently. There is no one perfect system to rule them all, and in the darkness bind them. Git may be the perfect fit for some people, while RCS may fit someone else better. This article is to provide yet another option to the mix. Mercurial provides some of the features of systems like git, and some of the features of systems like CVS or subversion. Hopefully by the end of this article you will have enough information to make a rational choice as to what is best for you. The main site contains lots of documentation for end users and developers alike. There are several tutroials available, and they even include a series of workflows that cover how end users may use mercurial for their development projects. Using these, you can see how you may use mercurial as a solo developer, or one of a group of developers, or how to work with a central repository like CVS. These workflows are great starting points for you to create your own.

We will first look at what mercurial consists of. A mercurial repository is made up of a working directory, which is paired with a store. The store is where the history of the repository is contained. Every working directory is paired with its own copy of the store. This means that mercurial has a distributed system, much like git. When you commit a series of file changes, a single changeset is created, encapsulating these changes. Each changeset gets a sequential number, called the revision number. But, remember that each working directory gets its own copy of the store, so these revision numbers may not actually match up. For this reason, each revision also gets a 40-digit hexadecimal globally unique ID. So, what happens when two users are doing parallel development? Assuming that they are starting with equal repositories, then any committed changes by user one creates a new branch, and any committed changes by user two also creates a new branch. User one then pulls in any changes from user two's repository. This creates two branches in user one's repository, one branch for his changes and one branch for user two's changes. He then needs to merge these two branches together in order to incorporate all of the changes since the last synchronization of repositories. User two would need to do the same thing (pull and merge) in order to get their repository synchronized. You can also push changes out to another repository, too. One of the strengths of mercurial is its use of extensions. There are several extensions available from the project, and you can always go ahead and write your own. Extensions are written in python, so go and get your scripting skills honed. These extensions are enabled by adding them to the '[extensions]' section of your configuration file.

So how do we actually use mercurial? You will probably want to set some basic configuration options in the file '.hgrc'. Mercurial needs a user name for recording commits. You can set this option in the configuration file with
   [ui]
   username = John Doe <john.doe@company.com>
The first thing to do is to create your local repository. If you are working off of a copy from someone else, you would make a clone. The format of the clone command is
   hg clone [OPTIONS...] SOURCE [DEST]
The source option can take several different forms. If the repository you are cloning is on the same machine, you can simply provide the filesystem path to the source repository. Mercurial includes a web server that can be used to provide access to a repository over HTTP. If you are cloning such a repository, the command would simply be
   hg clone http://[user[:pass]@]somemachine.com[:port]/[path][#revision]
You can also do this over HTTPS. We here at work keep backup copies of repositories on a machine that is only accessible over SSH. That's fine, because mercurial is perfectly happy cloning over SSH. You can use
   hg clone ssh://user@host[:port]/[path][#revision]
You need to have a valid login on the remote machine, of course. The path is relative to your home directory, so if you want to use a full path you will need to start it with two forward slashes.
   hg clone ssh://user@host//full/path/to/repo
Creating a new repository is even simpler. All you need to do is create a directory to house all of the files going into your repository. Then, you can cd to this directory and execute
   hg init
This command will create a subdirectory named '.hg', containing all of the store files for your new repository.

Changing the contents of your repository are done through the 'add' and 'remove' commands. There is also a 'rename' command which can be used to change the name of a file within your repository. This command can also be used to move files around within your repository. Let's say you want to move a file to subdirectory dir1. You would execute
   hg rename file1.c dir1
You can get the current state of a file with the command 'status'. This will tell you whether a file has been modified, added, removed, etc. The 'diff' command shows you the differences in a file from the current version and the last committed version. If you decide to simply toss away all of these changes, you can use the 'revert' command to reset the file to the last committed version. Once you are happy with your edits, you can commit any changes with the 'commit' command.

At the level of the repository as a whole, there are a lot of commands available. When you have done a lot of editing and committed all of your changes to your local copy of the repository, you can send the changes out to another repository with the 'push' command. The destination for the 'push' command can have any of the forms we saw above when we looked at the clone command. If the changes of interest were made by another user at a remote repository, you can use the 'pull' command to grab them and put them into your local repository. You may want to check what is going to happenbefore merging these changes. Before pushing changes out, you can use the 'outgoing' command to see what changesets would have been sent had you actually issued a 'push' command. For pulls, you can use the 'incoming' command to see what changesets would be brought in had you issued a 'pull' command. Once this is done, these changes sit in a separate branch. You then need to merge this branch back in to the main one in order to incorporate the changes. But what if you don't really have any kind of direct access over the network? You can use the 'bundle' command to generate a compressed file containing the changeset. This can then be transfered, either by email or sneakernet, to the remote repository. Once it is there, you can use the 'unbundle' command to import the changeset into the remote repository. Again, you can use the 'incoming' and 'outgoing' commands, with the '--bundle filename' option, to check out the changesets and see what they will do before actually running the real commands.

As I mentioned earlier, mercurial includes a web server that can provide access to your repository over HTTP. It is not appropriate to provide public full-time access to a repository, since it doesn't provide any type of user authentication. In those cases, you would use a real web server, like apache, to serve the repository up. But, if you simply want to through up the server for quick temporary access, or if you are just offering up access internally on a local network and don't need to worry too much about security, this gives you really quick access. You simply need to run
   hg serve [OPTIONS...]
Some of the more common options include '-d' or '--daemon'. This drops the mercurial web server into the background. You may want to set the port that it is listening on with the option '-p' or '--port'. The default port is 8000. You can push and pull from such a web server. If you want to serve over HTTPS rather than HTTP, you can use the option '--certificate' to set the SSL certificate file to use.

There are several clients available to work with mercurial repositories. For gnome users, there is a handy one called tortoise. The really handy part of this client is that it integrates nicely with nautilus. This means you can interact with your repository, commit changes, clone it, synchronize it with a remote repository and much more. You also get informational icons within nautilus, letting you see immediately which files are outdated, or changed, or whatever their status may be. All of the tools are simply a right-click away. There are also great stand alone clients available, so look around and find out you like. Hopefully this introduction gives you some ideas on what you can get done with mercurial. Now you don't have any excuses for not putting your source code under version control.

