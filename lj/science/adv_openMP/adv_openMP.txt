Advanced OpenMP

Since this issue's theme is programming, I thought we should look at some of the more advanced features available in openMP. Several issues ago, we looked at the basics of using openMP. You can go back and review if you need to. In scientific programming, this tends to be the limit of how people use openMP. But there is so much more available. And these other features are useful for so much more than just scientific computing. This month, we will delve into all of the other by-waters that never seem to get covered when looking at openMP programming. Who knows, you may even replace POSIX threads with openMP.

First, we should quickly review a little bit of the basics of openMP. All of the examples below will be done in C. If you remember, openMP is defined as a set of instructions to the compiler. This means that you need a compiler which supports openMP. The instructions to the compiler are given through pragmas. These pragmas are defined such that they appear as comments to a compiler which doesn't support openMP. The most usual construct is to use a for loop. Say you wanted to create an array of the sines of the integers from 1 to some maximum value. This would look like
   #pragma omp parallel for
   for (i=0; i<max; i++) {
      a[i] = sin(i);
   }
You would then compile this withh gcc by using the flag "-fopenmp". While this works great for problems that naturally form themselves into algorithms around for loops, this is far from the majority of solution schemes. In most cases, you need to be more flexible in your program design to handle more complicated parallel algorithms. To do this in openMP, enter the constructs of sections and tasks. With these, you should be able to do almost anything you would do with POSIX threads.

First, we'll look at sections. In the openMP specification, sections are defined as sequential blocks of code which can be run in parallel. You define them with a nested structure of pragma statements. The outer-most layer is the pragma
   #pragma omp parallel sections
   {
      ...commands...
   }
Remember that pragmas only apply to the next code block in C. Most simply, this means the next line of code. If you need to use more than one line, you will need to wrap them in curly braces, as above. This pragma forks off a number of new threads to handle the parallelized code. The number of threads that get created depends on what you set in the environment variable OMP_NUM_THREADS. So, if you wanted to use 4 threads, you would execute
   export OMP_NUM_THREADS=4
at the command line before running your program. Inside this sections region, you will need to define a series of individual section regions. Each of these is defined by
   #pragma omp section
   {
      ...commands...
   }

