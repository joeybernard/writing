Numerical Python

Over the last several months, we have covered several software packages for scientific computations. Over the next several months, we'll take a deeper look at using Python to come up with your own algorithms for your scientific problems. Python seems to be completely taking over the scientific communities for developing new code, so it is a good idea to have a good working knowledge of the fundamentals to be able to build up solutions to your own problems. We will start with numpy this month, scipy next month, and then look at some of the more complicated modules available the following month.

This month, we will start with the root module that almost all other scientific modules are built from, numpy. Out of the box, Python support real numbers and integers. You can also create complicated data structures with lists, sets and so on. This makes it very easy to write algorithms to solve scientific problems. But just diving in naively, without paying attention to what is happening under the hood, will lead to inefficient code. This is true with all programming languages, not just Python. Most scientific code needs to squeeze every last available cycle out of your hardware. One of the things to remember about Python is that it is a dynamic language where almost all functions and operators are polymorphic. This means that Python doesn't really know what needs to be done, at a hardware level, until it hits that operation. Unfortunately, this rules out any optimizations that can be made by rearranging operations to take advantage of how they are stored in memory and cache. One property of Python that causes a much larger problem is the polymorphism. In this case, Python needs to check the operands of any operator or function to see what type they are, decide whether this particular operand or function can handle these data types, then use the correct form of the operand or function to do the actual operation. In most cases, this is not really an issue since modern computers have become so fast. But in many scientific algorithms, you end applying the same operations to thousands, or millions, of data points.


URLs
http://www.numpy.org  -  Main website for numpy

