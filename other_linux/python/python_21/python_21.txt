@ Title (2-4 words) - 5 words
Learning About Your Raspberry Pi

@ Standfirst (20 words approx) - 19 words
This month, we will look at how you can monitor the Raspberry Pi itself and see what is happening.

@ Bio (20-30 words) - 23 words 
Joey Bernard is a true Renaissance man, splitting his time between building furniture, helping researchers with scientific computing problems and writing Android apps.

@ Body ( = 9400 - P characters, where P = [no. of lines of code in new paragraphs x 35] + [no. of new paragraphs for code x 70], eg 5 lines of code at 35 characters per line, split into 2 separate paragraphs rather than a single paragraph of five lines, means a reduction of 315 characters from the overall character count)  -  9499 characters
In previous articles, we have looked at how you can use your Raspberry Pi in order to monitor the environment around itself. But we haven't looked at how the Raspberry Pi can monitor itself, and see what is happening within itself. Luckily, Broadcom have included a command line utility, named 'vcgencmd', that is designed to get you exactly that type of information. You can get a full list of the commands available with the command 'vcgencmd commands'. The currently most complete documentation is available at 'http://elinux.org/RPI_vcgencmd_usage', but there is no official documentation available as of the writing of this article.The first step is to take a look at using the vcgencmd directly to see what you can do with it. We will then look at how to incorporate this into a Python program. The first piece of information you may want is the firmware version for your Raspberry Pi. You can get this with the command 'vcgencmd version'. One of the issues you may come upon is the way that memory is handled on the Raspberry Pi. The pool of RAM is divided between that available to the main CPU and that available to the GPU. You can check to see what the split is with the commands 'vcgencmd get_mem arm', for the CPU portion, and 'vcgencmd get_mem gpu', for the GPU portion. For people who are overclocking their Raspberry Pi's, there are a few commands that are essential. The first is the ability to check the relevant frequencies and verify that they are what they should be. The command 'vcgencmd measure_clock <clock>' will return the actual frequencies for various clocks used within the Raspberry Pi. The core clock frequency can be measured with the command 'vcgencmd measure_clock core'. You can also get the CPU clock frequency by using the 'arm' clock. On my Raspberry Pi, there are 12 separate clocks that can be measured. When you do overclock your Raspberry Pi, you need to be very careful of generating excess heat. Luckily, you can measure the internal temperature with the command 'vcgencmd measure_temp'. This return the internal temperature of the BCM2835 SoC in Centigrade degrees. For any American readers out there, you will need to do a small conversion in your code if you want that temperature in Fahrenheit degrees. The last item that is of importance to overclockers is the various voltages for the CPU and RAM systems. You can use the command 'vcgencmd measure_volts core' to get the core voltage. The various memory voltages can be measured with the options 'sdram_c', 'sdram_i' and 'sdram_p'. While these commands measure the actual values, you may need to see what the values are supposed to be based on the configuration values you set. You can see what these are with the command 'vcgencmd get_config'. This allows you to be able to make comparisons between what was supposed to be set to what is actually happening.Now that we can make these measurements, how can you use them within your own program? You need to be able to spawn off a process to run the command in question and then collect the resultant output so that you can do something interesting with it. The first step is to actually run the commands in question. There are a couple of common ways to get this functionality. The first is to use the subprocess Python module to launch a sub-process and collect the returned output. You can use the function 'check_output()' to launch your vcgencmd and store the results into a variable. You give your command and its command line options to the function with a list of strings, one element for each word. For example, if you wanted to find the current temperature, you could use   import subprocess   temp1 = subprocess.check_output(           ['/opt/vc/bin/vcgencmd',             'measure_temp'])	temp2 = temp1.split('=')[1]	curr_temp = float(temp2[:-3])The 'check_output()' function returns a string with the results from your executed command. The first step is to split the output on the equals sign so that you can get the actual numeric value. The temperature value is stored in the second element of the list generated from the split command. There is still the characters that represent the units of the temperature that need to be removed, so you can do that by using the slice 'temp2[:-3]'. This slice returns everything from the first character until the third from last character. This is still a string, however. In order to use it in calculations, you can use the 'float()' casting function to do the conversion from a string to a real number. You can now use the internal temperature of your Raspberry Pi. For example, you could decide to do a controlled shutdown if you register a temperature that is too high for safe continued operation.The second method available to run external commands is to use the 'os' Python module. In this case, you can use the 'popen()' function to launch a sub-process and create a pipe between it and your current Python process. This pipe stream behaves like any other file stream. So you can use the associated 'read()' function to get the results back from the vcgencmd command. As an example, say you wanted to get the current CPU frequency that has been configured, you can use something like   import os   c1 = os.popen('/opt/vc/bin/vcgencmd get_config arm_freq')   cpu_freq = c1.read()In both this example and the previous example, we used the full path to the executable vcgencmd. The reason for this is that the value of the PATH environment variable can be dramatically different from what you see when you SH in to your Raspberry Pi, depending on how these Python scripts are being run. Whenever you have any doubt as to what the environment variables are going to be set at, it is always best to err on the side of caution and use the full path to necessary files, like executables.This method of using 'os.popen()' to launch a sub-process has been deprecated, which means it will go away sometime in the future. But, there is still lots of code out there that uses it, so it is important to include how to use it here. More importantly, we should also include how you can migrate away from using it with minimal discomfort for you the program developer. In this case, you can similar behaviour with the class Popen, from the subprocess module. It accepts similar options to the 'os.popen()', but behaves much better in many more situations. The Popen equivalent to the above example would look like   import subprocess   c1 = Popen('/opt/vc/bin/vcgencmd get_config arm_freq',               stdout=PIPE)   c2 = c1.stdout   cpu_freq = c2.read()As you can see, there are only a few major changes. The first is making a couple of changes: one import statement and changing 'os.popen' to 'Popen'. The next change is to explicitly turn the standard output stream into a pipe, and the addition of the line where we select the standard output stream explicitly in the fourth line.Since we have introduced Popen in order to be able to use the vcgencmd command line utility, we should see what else we can do with it in other projects. These sub-processes that created by the Popen object are true sub-processes in the operating system sense. This means that they are running parallel to the current Python process. You can use this to do very rudimentary parallel processing. You can use this to run some other program in the background by calling 'Popen("my_program")' and let it run for some time. You can then check in on its progress a few different ways. You can use 'poll()' to see whether the backgrounded program has finished yet or not. When it has finished, the 'poll()' function will return the exit code from your secondary program. If you can't do anything else until this backgrounded process has finished, you can call 'wait()' instead. This function will block until the sub-process has finished its work. If you need to interact with your backgrounded process with a bit more functionality, you can use the function 'communicate()'. You can give it an option of a string that gets fed into the standard input stream of the background process. You get returned a tuple containing the data from the standard output and standard error streams. In order for this communication to work, you need to be sure to use the options 'stdin=PIPE', 'stdout=PIPE' and/or 'stderr=PIPE'. This function blocks on the return until either the background process dies or it gets an end-of-file marker. If you want to be able to interact without having your Python process block, you can write your background program to listen to and act on POSIX signals. You can then send in signals with the function 'send_signal()' and have it do interesting things based on these signals. The last thing you might need to do is to shutdown this process at some time. You can send a SIGTERM signal to the background process with the 'terminate()' function. SIGTERM signals can be ignored, however. So you might need to send in a SIGKILL signal. You can do that with the function 'kill()'.Now that you have seen the basics of vcgencmd, you can add the ability of monitoring your Raspberry Pi to you Python programs. This way, you can keep an eye on how your Raspberry Pi is doing when you deploy it into your project.

@ Boxout title (2-4 words)
Checking Your Raspberry Pi

@ Boxout text ( = 2200 - Q characters, where Q = [no. of lines of code in new paragraphs x 45] + [no. of new paragraphs for code x 90] )  -  2196 characters
While the vcgencmd utility can get you information from the hardware of your Raspberry Pi, it isn't the only way to do so. All of you Linux old-timers out there will be saying, "What about looking at /proc?". For those of you who may be newer to this, all Linux environments have a part of the filesystem under the directory '/proc'. This subdirectory contains all sorts of information that the Linux kernel knows about. All of the information sources look like files to any programs you may wish to use. So for all of these, you can access the relevant information with a 'cat' command. For example, you could get the CPU information with the code   import subprocess   cpu = Popen('cat /proc/cpuinfo', stdout=PIPE)   cpu_info = cpu.stdoutYou can also get memory information from '/proc/meminfo'. This interface provides information on physical memory usage and swap usage. If you need to find out how your Raspberry Pi is being used, you can use the interface 'loadavg'. This will give you the load average value for the system for the last 1, 5 and 15 minutes. If you are keeping your Raspberry Pi busy, the load average should be ideally equal to the number of cores available. You can find out what devices are connected to your Raspberry Pi and able to be used by looking at the interface 'devices'. You can use this to verify that the device you want to use in your program is there and that the kernel recognizes it.An available wrapper around these interfaces is the psutil module. You can install it using 'pip install psutil'. You can then grab information using code like   import psutil   psutil.virtual_memory()to get the current memory usage. While you are limited to the presentation of the information that the developers thought appropriate, this module might give you everything you need, without the need to do the parsing yourself. Otherwise, you can still get at the raw data with the technique above.

@ Full code listing (optional, no more than 50 lines of code at 70 characters per line; if this is supplied, change the body text to (6100 - P) characters)
xxxx
