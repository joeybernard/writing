@ Title (2-4 words) - 5 words
Adding multimedia to your Pi

@ Standfirst (20 words approx) - 31 words
Everyone likes to have some form of multimedia in their programs. While you can use lots of separate, specialized modules to handle this, using the pygame module provides a one-stop shop.

@ Bio (20-30 words)
Joey Bernard is a true Renaissance man, splitting his time between building furniture, helping researchers with scientific computing problems and writing Android apps

@ Body ( = 9400 - P characters, where P = [no. of lines of code in new paragraphs x 35] + [no. of new paragraphs for code x 70], eg 5 lines of code at 35 characters per line, split into 2 separate paragraphs rather than a single paragraph of five lines, means a reduction of 315 characters from the overall character count) 9723 characters
There are lots of times that you may want to use multimedia within your interactions with an end user. You may want to display some really interesting piece of video, or have your program chat audibly with the user. In all of these cases, there are lots of modules available to allow you to work all of these other forms of data. But, one truism about programming is "Find the easiest way to do something". In this case, this means if you can find a single framework that provides everything you need, you should probably use it. This is the role that the module pygame fills. This isn't to say that you will be able to do everything you may want to do with pygame, but you should never under sell the worth of your time in learning and using multiple modules and the way multiple development groups think in their coding styles. This article will cover at least some of the various methods and techniques you can use to interact with your users in some form other than text.It is written to be as portable as possible. In order to do this, it supports many different graphics backends, from OpenGL to even using ASCII text to display graphics. It is designed to use all of the computing resources, i.e. CPUs and GPUs, available to do the type of calculations required when playing with these types of files. In order to get the best performance out of your hardware, several of the heaviest functions are written in optimized C. This gets you a 10-20 fold speed increase. In the most sensitive code sections, optimized assembly language is used to get even more performance. All of this means that even your Raspberry Pi can get pretty impressive output with its limited resources. Installing pygame can be pretty messy to install. Depending on which video and audio backends are to be supported, you need to have all of the optimized C and assembler code we mentioned above compiled. For your Raspberry Pi, the simplest solution is to use "sudo apt-get install python-pygame" to deal with all of the potential headaches. The documentation available at the main home page (http://www.pygame.org) is very extensive. There are several tutorials, and there is even a recipe section where you can find recipes outlining techniques for specific effect and interactions.The first step is to import the pygame module. Pygame provides a complete multimedia subsystem, so you need to call "pygame.init()" before being able to use any of the functionality it provides. This initializes everything and loads all of the module contents for you. We will start by looking at displaying video to your users. The first thing you need is somewhere to do the actual displaying of your video. When you called "pygame.init()", the pygame subsystem should have created a display object with the best display mode available on your current device. You may want something else, in order to make your program behave the way you want it to. You can create a new graphic display with the function "pygame.display.set_mode()", where you can give the function a sequence with a width and a height value. The actual object that you draw images on is called a surface in pygame. The display that you just created has a surface object associated with it. Anything that you draw on this surface get displayed immediately on the screen. This is usually not what you do, however. The usual technique is to create an offscreen drawing area and do your drawing there. Then, you can dump the entire contents of the image onto the actual display in one movement. This is much more efficient than trying to draw on the screen fast enough to look good to the user. This dumping of image data to the screen is handled with the "blit()" function of the surface object. This takes data from one surface and moves it to a location on the second surface. In order to get this surface displayed on the physical monitor, you need to call the "flip()" function. This function takes the entire surface and dumps it into the physical hardware as the last step for display.The first way to draw we will look at is to load an entire image file into Python. There is a function, "pygame.image.load()" that will read in an image file and load it into a new surface object. By default, pygame can only load uncompressed BMP files. The load function includes a translation layer that can handle converting and importing several other formats, such as JPEG, GIF, PNG and others. For some of these other formats, you may wish to call the image's "convert()" method to convert it to the natural format. It will then be faster to use. When you wish to save images, your options are more limited. You can only save to the formats BMP, TGA, PNG and JPEG. If you need a different format, you can always convert it after it has been saved by pygame.Whether you are starting with a loaded image, or with a blank surface, you will probably want to be able to draw on them. There is a whole suite of drawing functions under the "pygame.image" namespace that gives you that functionality. The first parameter in all of these functions is a surface on which to draw. This surface could be a previously loaded image, or a blank canvas. For example, you could draw a circle with the function "pygame.image.circle(Surface, color, pos, radius, width=0)". This function draws a circle with the given radius, at the position given on the surface object. The width parameter tells pygame how wide to make the circumference of your circle. If the width is set to 0, then that means you want a solid filled in circle drawn. This function will also return a rectangle object which represents the bounding rectangle of the pixels that changed. This is important if you are doing animation and need to track sprites as they move around. There are also functions to draw polygons, lines, and rectangles, among other shapes.Once you have finished all of the graphics you want to do, you will need to call "pygame.quit()". This function cleans up all of the shared memory and graphics devices that had been created. You only need to worry about this if your program is going to continue doing work after you are done with the graphical display items. Otherwise, everything should be cleaned up properly when the Python interpreter exits at the end of your program run.The other way of interacting with the users of your program is through audio. The required functionality is provided through "pygame.mixer". Just as with the image system, the audio system must be initialized before you can use it. This handled by the function "pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=4096)", where the values shown here are the defaults. The first parameter gives the sampling frequency for the audio, the second parameter gives the number of bits used to hold each sample, the third parameter sets whether the audio is mono (channels=1) or stereo (channels=2), and the last parameter sets the size of the internal buffer used by the mixer for audio processing. You can create a new sound object from an audio file with the function "pygame.mixer.Sound(filename)". This function loads the entire audio file into a buffer. This may be an issue if you are dealing with larger files, like music files. In these cases, you can use a streaming function like "pygame.mixer.music.load(filename)". Both of these groups, "pygame.mixer" and "pygame.mixer.music", contain several functions that help you manipulate audio data. The first thing to do is to start playing your audio file. The returned sound object from "pygame.mixer.Sound()" has a play method that starts the audio playing on the next available channel. The mixer portion of pygame can handle 8 audio channels, so you can have multiple audio files playing at the same time. If you want to play audio on a specific channel, you can create a new channel object tied to a specific channel ID, and then play specific sound objects on them. There are helper functions that can get and set the current volume for a playing sound object. You can also pause and unpause them. When you want things to go quiet, you can either call "stop()" to end it quickly, or "fadeout(time)" where the sound will fadeout over 'time' milliseconds before stopping. Just as with the image system, you need to call "pygame.mixer.quit()" to cleanly shutdown the audio system and release all of the resources that were used for your sound playback.The two sections above described how you can produce output for your end users, but how can you get input from them? Pygame can help you out here, as well. You can get image information using the "pygame.camera.Camera" object. The physical camera you want to use needs to be recognized by the operating system before you can use it. Once it is, you can get a list of all available cameras with the function "pygame.camera.list_cameras()". Once you have selected a camera to use, you can create a new camera object that is tied to it with the constructor "pygame.camera.Camera()". The camera object's method "start()" connects to the camera, initializes it and starts to record images from it. These images are placed into a buffer for further use. When you are ready to work with these images, you can start to pull them from this buffer with the function "get_image()". This function returns the retrieved image into a new surface object. If you want to reuse an existing surface, you hand it in as a parameter to the function call. Unfortunately, pygame isn't able to record audio directly. If you want to do this, you will need to use a different module, such as pymedia.Now that we've covered the basics, you should be able to use pygame to add multimedia functionality to your next Python project on your Raspberry Pi.

@ Boxout title (2-4 words) 3 words
What about movies?

@ Boxout text ( = 2200 - Q characters, where Q = [no. of lines of code in new paragraphs x 45] + [no. of new paragraphs for code x 90] ) 2193 charactersWhile playing audio and showing images is good, sometimes a video is the clearest way to display output. Luckily, pygame can help you with this, too. There is a movie object available that can handle the playback of MPEG-1 video files. The constructor takes a filename for the movie file, and looks like "pygame.movie.Movie(filename)". You can check the data and see whether there is video data or audio data with the helper functions "has_audio()" and "has_video()". Movie objects need to be displayed on some surface. The default surface that the movie object will use is the display surface. You can change this to a different surface with the method "set_display()". This draws over everything on the surface, so you may want to actually draw on an offscreen surface and blit it to the display surface once each frame.When it comes to audio, you do need to be a bit careful. The movie object expects to have total control over the audio on your Raspberry Pi, so you need to be sure that you don't have the mixer running. If there is a chance that it might be running, you can always guarantee that you don't have any conflicts by calling "pygame.mixer.quit()" before starting your movie. You can change the playback volume with the method "set_volume()", giving a value between 0.0 and 1.0.Once the file is loaded, you can start playback with the method "play()" and stop it again with the method "stop()". If you want to just temporarily stop the playback, you can use the "pause()" method. You can restart it by calling the pause method again. If you want to start playback at some fixed point, you can use the "skip()" method to jump ahead some number of seconds. You can only jump forward, however. If you need to move backwards, you can use the "rewind()" method to move back to the beginning and then call skip from there to jump to the desired point. You can also move around by selecting a specific frame to move to. This might be a tad bit difficult to calculate, though. You can use the method "get_frame()" to get the current frame number. You can then use that as a starting point, adjust the value and use "render_frame(id)" to move the video to the frame you want to display.


@ Full code listing (optional, no more than 50 lines of code at 70 characters per line; if this is supplied, change the body text to (6100 - P) characters)
xxxx
