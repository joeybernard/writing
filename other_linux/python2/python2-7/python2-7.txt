Pi code-based tutorial, 4 pages
-feel free to include commands and small segments of code in-line with the body text, but for larger chunks of code please use figure references or refer people to the coverdisc as we can supply them with code, if you send it in with your commission.
Note: please indicate where code starts and ends with /c/ and any output with /o/, as it enables a non-tech savvy art person to layout the pages e.g.
/c/
$ telnet 192.168.1.200 8000
/c/
/o/
Trying 192.168.1.200...
/o/

Code takes up a lot of space, so if you decide to separate out any code onto a line on its own you will need to REMOVE words from the total word count for the section your writing. This works out as follows:
One line of code is equal to 30 words (we have a line break before and after code that is being pulled out of the body copy, which is why it takes up more space), two lines of code are equal to 40 words and three lines are equal to 50 words and so on.

Note: We've included the number of characters as an extra useful reference for each section as sometimes a word count can be less accurate depending on the length of words that are used.

@ Title  -  9 words
Using ipyparallel to put your Raspberry Pis to work



@ Standfirst  -  30 words
There are lots of methods to run parallel code on your network of Raspberry Pis. This month, we will look at how to use ipyparallel to run parallel Python code.



@ Profile  -  44 words
[Joey Bernard]
Joey Bernard has written a column on scientific software, as well as a column on writing Python code for the Raspberry Pi. In his day job, he helps researchers and students at the university level in designing and running HPC projects on supercomputing clusters.



@ Resources
List everything required for this tutorial and provide URLs if applicable.
If you are using hardware, mention it and a possible stockist. For software, please provide a URL.

@ Lead image
Supply an engaging main image to illustrate the feature (grey box in the example PDF); either an interesting, representative and uncropped screenshot of the software, or if there is nothing appropriate then either round up all of the relevant icons or suggest a possible illustration or diagram recreation and we will create some artwork in-house.

NOTE: this compulsory as you can see from the PDF this is large on the first page. If you have an idea for an illustration or a hardware shot, please contact us as early as you can to allow us to get that organised.

Total word count is 2,952 (roughly 16,940 char).


@ Intro text  -  185 words
Raspberry Pi provides a very powerful, yet very energy efficient, computing package. While its portability has made a great platform for mobile applications, there is a lot of "real" computing that can be done on them as well. This month, we will look at how you can run parallel Python code on a network of Raspberry Pis. Specifically, we will look at setting up a cluster of Raspberry Pis with ipyparallel, and how to run prallel code on this cluster.

You will want to start by physically connecting the Raspberry Pis together over a network. This may be a small local network, where they are all connected to same router or switch. In all of the examples in the rest of this article, I will be assuming that the Raspberry Pis all have static IP addresses in the range of 192.168.0.1 to 192.168.0.255, since these are reserved for internal local networks. From here, we will move on to setting up the software and actually running jobs. You should end up with probably the quietest and most energy efficient supercomputing.



@ Body text
2,752 words (rouhgly 15,800 chars)
Use 8 subheadings (or crossheads) to break this text up.
@ Subheading 1  -  Introduction
Ipyparallel is a Python module that adds the ability to to Ipython run multiple Ipython engines and have them talk to each other. These could be on a single machine, but in order to maximize the amount of computing you can do, they can be run on multiple separate machines. Ipyparallel is built on a layered structure of three main parts: a controller, one or more clients and one or more engines. The engines are the IPython kernels that actually run your Python code. In our setup here, these engines will be distributed across all of the connected Raspberry Pis. The clients are the Python programs that connect to your ipyparallel cluster and request for computations to be done. This is where you actually define the tasks that need to be done and fire them off. The controller is the core of your ipyparallel cluster. It is actually made up of a hub and one or more schedulers. The hub manages the entire cluster and all of the communications between all of the parts. The schedulers wrap the engines and manage the amount of work being given to them.

@ Subheading 2  -  Installation
The first step is to install ipyparallel on your Raspberry Pi. It is not likely to be in the package repository of whatever distribution you are using. This means that in most cases, you will need to install it using pip. This also means that you will need to install pip first. In Debian-based distributions, like Raspbian, you can install it with the following command.
/c/
sudo apt-get install python-pip
/c/
If you are using Python 3.X, you will want to install 'python3-pip' instead. Once pip installed, you can install ipyparallel with the following command.
/c/
sudo pip install ipyparallel
/c/
If you are using Python 2.X, you may run into an issue here. The latest versions of ipyparallel don't support older versions of Python 2.X and 3.X, and you are more likely to have an older version of Python 2.X. This is because most projects are moving to Python 3.X. If you run into this problem, your two choices are either to move to Python 3.X or install an updated Python 2.X. That will depend on the other requirements of your project. While you don't necessarily need to do the same thing on every Raspberry Pi, especially the clients, it is probably the easiest way to make sure that all of the support libraries and Python modules are installed. So, for the rest of this article, I will assume that you went ahead and simply installed the full ipyparallel module on all of the Raspberry Pis being used.

@ Subheading 3  -  Setting up the master
The master Raspberry Pi node will be the main controller that will be called the master node in the rest of this article. On this master node, you need to start up the controller portion of ipyparallel so that all of the other nodes have somewhere to connect to. The program you use for this step is the 'ipcontroller' executable. One of the most important command line options to this command is '--ip=XXXX', where 'XXXX' is the IP address that the ipyparallel controller is allowed to listen on. If your Raspberry Pi cluster is completely isolated on its own private network, you can set this option to '*'. The complete command would look like the following.
/c/
ipcontroller --ip='*'
/c/
Otherwise, you should be sure to set this to the IP address of the master node. Once this has started up, you will see 

@ Subheading 4  -  Setting up the clients
The bulk of your Raspberry Pis will be setup as clients to execute all of the parallel code that you will be running. These clients need to be 


@ Subheading 5  -  Running a test
@ Subheading 6  -  Running tasks  
@ Subheading 7  -  Connecting from jupyter
@ Subheading 8  -  Where to now?




@ Supporting images
3 images required; please indicate whether we need to crop in on a particular part of a screenshot.

If you wish to include diagrams, supply a reference copy and we will re-create this in-house.

If you are referencing sections of code, please make them as Figure 1, 2 and so on and mention them in the copy.

@ Captions
Images need captions, which need to be around 15 words each.

A note on captions:
These are a device intended to provide additional information that's not directly in the text of the tutorial or simply stating what the picture is of. A caption that effectively says 'This is X' isn't a good caption.

@ 2x boxouts
60 words each (roughly 350 chars); Needs a title up to 5 words. The contents can be a general tip/trick or piece of knowledge related to this tutorial, or you can go into greater depth on one particular aspect of it.

A note on boxouts:
Boxouts are intended to be 'access points' into the page, so they are meant to be interesting little reads in their own right that hopefully encourage someone scanning the page to dip into the whole tutorial. You can never assume that the reader is actually going to read your words, you have to use all the tricks to encourage them to read.

@ 2x Pullquotes
Choose a short quote, around 15 words, to pull the reader in as they flick through the pages.


[IMAGE USAGE FORM INFO: PLEASE GIVE COMPANY AND CONTACT DETAILS FOR THE IMAGES USED IN THIS FEATURE]
